
/*
 * NetBox API
 *
 * API to access NetBox
 *
 * API version: 2.8
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package netbox_client

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ExtrasApiService service

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param data

@return ConfigContext
*/
func (a *ExtrasApiService) ExtrasConfigContextsCreate(ctx context.Context, data WritableConfigContext) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this config context.


*/
func (a *ExtrasApiService) ExtrasConfigContextsDelete(ctx context.Context, id int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasConfigContextsListOpts - Optional Parameters:
     * @param "Id" (optional.String) -  
     * @param "Name" (optional.String) -  
     * @param "IsActive" (optional.String) -  
     * @param "Q" (optional.String) -  
     * @param "RegionId" (optional.String) -  
     * @param "Region" (optional.String) -  
     * @param "SiteId" (optional.String) -  
     * @param "Site" (optional.String) -  
     * @param "RoleId" (optional.String) -  
     * @param "Role" (optional.String) -  
     * @param "PlatformId" (optional.String) -  
     * @param "Platform" (optional.String) -  
     * @param "ClusterGroupId" (optional.String) -  
     * @param "ClusterGroup" (optional.String) -  
     * @param "ClusterId" (optional.String) -  
     * @param "TenantGroupId" (optional.String) -  
     * @param "TenantGroup" (optional.String) -  
     * @param "TenantId" (optional.String) -  
     * @param "Tenant" (optional.String) -  
     * @param "Tag" (optional.String) -  
     * @param "IdN" (optional.String) -  
     * @param "IdLte" (optional.String) -  
     * @param "IdLt" (optional.String) -  
     * @param "IdGte" (optional.String) -  
     * @param "IdGt" (optional.String) -  
     * @param "NameN" (optional.String) -  
     * @param "NameIc" (optional.String) -  
     * @param "NameNic" (optional.String) -  
     * @param "NameIew" (optional.String) -  
     * @param "NameNiew" (optional.String) -  
     * @param "NameIsw" (optional.String) -  
     * @param "NameNisw" (optional.String) -  
     * @param "NameIe" (optional.String) -  
     * @param "NameNie" (optional.String) -  
     * @param "RegionIdN" (optional.String) -  
     * @param "RegionN" (optional.String) -  
     * @param "SiteIdN" (optional.String) -  
     * @param "SiteN" (optional.String) -  
     * @param "RoleIdN" (optional.String) -  
     * @param "RoleN" (optional.String) -  
     * @param "PlatformIdN" (optional.String) -  
     * @param "PlatformN" (optional.String) -  
     * @param "ClusterGroupIdN" (optional.String) -  
     * @param "ClusterGroupN" (optional.String) -  
     * @param "ClusterIdN" (optional.String) -  
     * @param "TenantGroupIdN" (optional.String) -  
     * @param "TenantGroupN" (optional.String) -  
     * @param "TenantIdN" (optional.String) -  
     * @param "TenantN" (optional.String) -  
     * @param "TagN" (optional.String) -  
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.

@return InlineResponse20037
*/

type ExtrasApiExtrasConfigContextsListOpts struct { 
	Id optional.String
	Name optional.String
	IsActive optional.String
	Q optional.String
	RegionId optional.String
	Region optional.String
	SiteId optional.String
	Site optional.String
	RoleId optional.String
	Role optional.String
	PlatformId optional.String
	Platform optional.String
	ClusterGroupId optional.String
	ClusterGroup optional.String
	ClusterId optional.String
	TenantGroupId optional.String
	TenantGroup optional.String
	TenantId optional.String
	Tenant optional.String
	Tag optional.String
	IdN optional.String
	IdLte optional.String
	IdLt optional.String
	IdGte optional.String
	IdGt optional.String
	NameN optional.String
	NameIc optional.String
	NameNic optional.String
	NameIew optional.String
	NameNiew optional.String
	NameIsw optional.String
	NameNisw optional.String
	NameIe optional.String
	NameNie optional.String
	RegionIdN optional.String
	RegionN optional.String
	SiteIdN optional.String
	SiteN optional.String
	RoleIdN optional.String
	RoleN optional.String
	PlatformIdN optional.String
	PlatformN optional.String
	ClusterGroupIdN optional.String
	ClusterGroupN optional.String
	ClusterIdN optional.String
	TenantGroupIdN optional.String
	TenantGroupN optional.String
	TenantIdN optional.String
	TenantN optional.String
	TagN optional.String
	Limit optional.Int32
	Offset optional.Int32
}

func (a *ExtrasApiService) ExtrasConfigContextsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasConfigContextsListOpts) (InlineResponse20037, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20037
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsActive.IsSet() {
		localVarQueryParams.Add("is_active", parameterToString(localVarOptionals.IsActive.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RegionId.IsSet() {
		localVarQueryParams.Add("region_id", parameterToString(localVarOptionals.RegionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Region.IsSet() {
		localVarQueryParams.Add("region", parameterToString(localVarOptionals.Region.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SiteId.IsSet() {
		localVarQueryParams.Add("site_id", parameterToString(localVarOptionals.SiteId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Site.IsSet() {
		localVarQueryParams.Add("site", parameterToString(localVarOptionals.Site.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoleId.IsSet() {
		localVarQueryParams.Add("role_id", parameterToString(localVarOptionals.RoleId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Role.IsSet() {
		localVarQueryParams.Add("role", parameterToString(localVarOptionals.Role.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformId.IsSet() {
		localVarQueryParams.Add("platform_id", parameterToString(localVarOptionals.PlatformId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Platform.IsSet() {
		localVarQueryParams.Add("platform", parameterToString(localVarOptionals.Platform.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterGroupId.IsSet() {
		localVarQueryParams.Add("cluster_group_id", parameterToString(localVarOptionals.ClusterGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterGroup.IsSet() {
		localVarQueryParams.Add("cluster_group", parameterToString(localVarOptionals.ClusterGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterId.IsSet() {
		localVarQueryParams.Add("cluster_id", parameterToString(localVarOptionals.ClusterId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupId.IsSet() {
		localVarQueryParams.Add("tenant_group_id", parameterToString(localVarOptionals.TenantGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroup.IsSet() {
		localVarQueryParams.Add("tenant_group", parameterToString(localVarOptionals.TenantGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenant_id", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarQueryParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLte.IsSet() {
		localVarQueryParams.Add("id__lte", parameterToString(localVarOptionals.IdLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLt.IsSet() {
		localVarQueryParams.Add("id__lt", parameterToString(localVarOptionals.IdLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGte.IsSet() {
		localVarQueryParams.Add("id__gte", parameterToString(localVarOptionals.IdGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGt.IsSet() {
		localVarQueryParams.Add("id__gt", parameterToString(localVarOptionals.IdGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RegionIdN.IsSet() {
		localVarQueryParams.Add("region_id__n", parameterToString(localVarOptionals.RegionIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RegionN.IsSet() {
		localVarQueryParams.Add("region__n", parameterToString(localVarOptionals.RegionN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SiteIdN.IsSet() {
		localVarQueryParams.Add("site_id__n", parameterToString(localVarOptionals.SiteIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SiteN.IsSet() {
		localVarQueryParams.Add("site__n", parameterToString(localVarOptionals.SiteN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoleIdN.IsSet() {
		localVarQueryParams.Add("role_id__n", parameterToString(localVarOptionals.RoleIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoleN.IsSet() {
		localVarQueryParams.Add("role__n", parameterToString(localVarOptionals.RoleN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformIdN.IsSet() {
		localVarQueryParams.Add("platform_id__n", parameterToString(localVarOptionals.PlatformIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlatformN.IsSet() {
		localVarQueryParams.Add("platform__n", parameterToString(localVarOptionals.PlatformN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterGroupIdN.IsSet() {
		localVarQueryParams.Add("cluster_group_id__n", parameterToString(localVarOptionals.ClusterGroupIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterGroupN.IsSet() {
		localVarQueryParams.Add("cluster_group__n", parameterToString(localVarOptionals.ClusterGroupN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterIdN.IsSet() {
		localVarQueryParams.Add("cluster_id__n", parameterToString(localVarOptionals.ClusterIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupIdN.IsSet() {
		localVarQueryParams.Add("tenant_group_id__n", parameterToString(localVarOptionals.TenantGroupIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantGroupN.IsSet() {
		localVarQueryParams.Add("tenant_group__n", parameterToString(localVarOptionals.TenantGroupN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdN.IsSet() {
		localVarQueryParams.Add("tenant_id__n", parameterToString(localVarOptionals.TenantIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantN.IsSet() {
		localVarQueryParams.Add("tenant__n", parameterToString(localVarOptionals.TenantN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagN.IsSet() {
		localVarQueryParams.Add("tag__n", parameterToString(localVarOptionals.TagN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20037
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this config context.
 * @param data

@return ConfigContext
*/
func (a *ExtrasApiService) ExtrasConfigContextsPartialUpdate(ctx context.Context, id int32, data WritableConfigContext) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this config context.

@return ConfigContext
*/
func (a *ExtrasApiService) ExtrasConfigContextsRead(ctx context.Context, id int32) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this config context.
 * @param data

@return ConfigContext
*/
func (a *ExtrasApiService) ExtrasConfigContextsUpdate(ctx context.Context, id int32, data WritableConfigContext) (ConfigContext, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ConfigContext
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/config-contexts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ConfigContext
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().


*/
func (a *ExtrasApiService) ExtrasCustomFieldChoicesList(ctx context.Context) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/_custom_field_choices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id


*/
func (a *ExtrasApiService) ExtrasCustomFieldChoicesRead(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/_custom_field_choices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param data

@return ExportTemplate
*/
func (a *ExtrasApiService) ExtrasExportTemplatesCreate(ctx context.Context, data WritableExportTemplate) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this export template.


*/
func (a *ExtrasApiService) ExtrasExportTemplatesDelete(ctx context.Context, id int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasExportTemplatesListOpts - Optional Parameters:
     * @param "Id" (optional.String) -  
     * @param "ContentType" (optional.String) -  
     * @param "Name" (optional.String) -  
     * @param "TemplateLanguage" (optional.String) -  
     * @param "IdN" (optional.String) -  
     * @param "IdLte" (optional.String) -  
     * @param "IdLt" (optional.String) -  
     * @param "IdGte" (optional.String) -  
     * @param "IdGt" (optional.String) -  
     * @param "ContentTypeN" (optional.String) -  
     * @param "NameN" (optional.String) -  
     * @param "NameIc" (optional.String) -  
     * @param "NameNic" (optional.String) -  
     * @param "NameIew" (optional.String) -  
     * @param "NameNiew" (optional.String) -  
     * @param "NameIsw" (optional.String) -  
     * @param "NameNisw" (optional.String) -  
     * @param "NameIe" (optional.String) -  
     * @param "NameNie" (optional.String) -  
     * @param "TemplateLanguageN" (optional.String) -  
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.

@return InlineResponse20038
*/

type ExtrasApiExtrasExportTemplatesListOpts struct { 
	Id optional.String
	ContentType optional.String
	Name optional.String
	TemplateLanguage optional.String
	IdN optional.String
	IdLte optional.String
	IdLt optional.String
	IdGte optional.String
	IdGt optional.String
	ContentTypeN optional.String
	NameN optional.String
	NameIc optional.String
	NameNic optional.String
	NameIew optional.String
	NameNiew optional.String
	NameIsw optional.String
	NameNisw optional.String
	NameIe optional.String
	NameNie optional.String
	TemplateLanguageN optional.String
	Limit optional.Int32
	Offset optional.Int32
}

func (a *ExtrasApiService) ExtrasExportTemplatesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasExportTemplatesListOpts) (InlineResponse20038, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20038
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentType.IsSet() {
		localVarQueryParams.Add("content_type", parameterToString(localVarOptionals.ContentType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateLanguage.IsSet() {
		localVarQueryParams.Add("template_language", parameterToString(localVarOptionals.TemplateLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLte.IsSet() {
		localVarQueryParams.Add("id__lte", parameterToString(localVarOptionals.IdLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLt.IsSet() {
		localVarQueryParams.Add("id__lt", parameterToString(localVarOptionals.IdLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGte.IsSet() {
		localVarQueryParams.Add("id__gte", parameterToString(localVarOptionals.IdGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGt.IsSet() {
		localVarQueryParams.Add("id__gt", parameterToString(localVarOptionals.IdGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContentTypeN.IsSet() {
		localVarQueryParams.Add("content_type__n", parameterToString(localVarOptionals.ContentTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateLanguageN.IsSet() {
		localVarQueryParams.Add("template_language__n", parameterToString(localVarOptionals.TemplateLanguageN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20038
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this export template.
 * @param data

@return ExportTemplate
*/
func (a *ExtrasApiService) ExtrasExportTemplatesPartialUpdate(ctx context.Context, id int32, data WritableExportTemplate) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this export template.

@return ExportTemplate
*/
func (a *ExtrasApiService) ExtrasExportTemplatesRead(ctx context.Context, id int32) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this export template.
 * @param data

@return ExportTemplate
*/
func (a *ExtrasApiService) ExtrasExportTemplatesUpdate(ctx context.Context, id int32, data WritableExportTemplate) (ExportTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/export-templates/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportTemplate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param data

@return Graph
*/
func (a *ExtrasApiService) ExtrasGraphsCreate(ctx context.Context, data Graph) (Graph, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Graph
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v Graph
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this graph.


*/
func (a *ExtrasApiService) ExtrasGraphsDelete(ctx context.Context, id int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasGraphsListOpts - Optional Parameters:
     * @param "Id" (optional.String) -  
     * @param "Type_" (optional.String) -  
     * @param "Name" (optional.String) -  
     * @param "TemplateLanguage" (optional.String) -  
     * @param "IdN" (optional.String) -  
     * @param "IdLte" (optional.String) -  
     * @param "IdLt" (optional.String) -  
     * @param "IdGte" (optional.String) -  
     * @param "IdGt" (optional.String) -  
     * @param "TypeN" (optional.String) -  
     * @param "NameN" (optional.String) -  
     * @param "NameIc" (optional.String) -  
     * @param "NameNic" (optional.String) -  
     * @param "NameIew" (optional.String) -  
     * @param "NameNiew" (optional.String) -  
     * @param "NameIsw" (optional.String) -  
     * @param "NameNisw" (optional.String) -  
     * @param "NameIe" (optional.String) -  
     * @param "NameNie" (optional.String) -  
     * @param "TemplateLanguageN" (optional.String) -  
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.

@return InlineResponse20039
*/

type ExtrasApiExtrasGraphsListOpts struct { 
	Id optional.String
	Type_ optional.String
	Name optional.String
	TemplateLanguage optional.String
	IdN optional.String
	IdLte optional.String
	IdLt optional.String
	IdGte optional.String
	IdGt optional.String
	TypeN optional.String
	NameN optional.String
	NameIc optional.String
	NameNic optional.String
	NameIew optional.String
	NameNiew optional.String
	NameIsw optional.String
	NameNisw optional.String
	NameIe optional.String
	NameNie optional.String
	TemplateLanguageN optional.String
	Limit optional.Int32
	Offset optional.Int32
}

func (a *ExtrasApiService) ExtrasGraphsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasGraphsListOpts) (InlineResponse20039, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20039
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateLanguage.IsSet() {
		localVarQueryParams.Add("template_language", parameterToString(localVarOptionals.TemplateLanguage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLte.IsSet() {
		localVarQueryParams.Add("id__lte", parameterToString(localVarOptionals.IdLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLt.IsSet() {
		localVarQueryParams.Add("id__lt", parameterToString(localVarOptionals.IdLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGte.IsSet() {
		localVarQueryParams.Add("id__gte", parameterToString(localVarOptionals.IdGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGt.IsSet() {
		localVarQueryParams.Add("id__gt", parameterToString(localVarOptionals.IdGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TypeN.IsSet() {
		localVarQueryParams.Add("type__n", parameterToString(localVarOptionals.TypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateLanguageN.IsSet() {
		localVarQueryParams.Add("template_language__n", parameterToString(localVarOptionals.TemplateLanguageN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20039
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this graph.
 * @param data

@return Graph
*/
func (a *ExtrasApiService) ExtrasGraphsPartialUpdate(ctx context.Context, id int32, data Graph) (Graph, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Graph
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Graph
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this graph.

@return Graph
*/
func (a *ExtrasApiService) ExtrasGraphsRead(ctx context.Context, id int32) (Graph, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Graph
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Graph
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this graph.
 * @param data

@return Graph
*/
func (a *ExtrasApiService) ExtrasGraphsUpdate(ctx context.Context, id int32, data Graph) (Graph, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Graph
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/graphs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Graph
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param data

@return ImageAttachment
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsCreate(ctx context.Context, data ImageAttachment) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this image attachment.


*/
func (a *ExtrasApiService) ExtrasImageAttachmentsDelete(ctx context.Context, id int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasImageAttachmentsListOpts - Optional Parameters:
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.

@return InlineResponse20040
*/

type ExtrasApiExtrasImageAttachmentsListOpts struct { 
	Limit optional.Int32
	Offset optional.Int32
}

func (a *ExtrasApiService) ExtrasImageAttachmentsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasImageAttachmentsListOpts) (InlineResponse20040, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20040
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20040
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this image attachment.
 * @param data

@return ImageAttachment
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsPartialUpdate(ctx context.Context, id int32, data ImageAttachment) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this image attachment.

@return ImageAttachment
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsRead(ctx context.Context, id int32) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this image attachment.
 * @param data

@return ImageAttachment
*/
func (a *ExtrasApiService) ExtrasImageAttachmentsUpdate(ctx context.Context, id int32, data ImageAttachment) (ImageAttachment, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ImageAttachment
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/image-attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ImageAttachment
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Retrieve a list of recent changes.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasObjectChangesListOpts - Optional Parameters:
     * @param "Id" (optional.String) -  
     * @param "User" (optional.String) -  
     * @param "UserName" (optional.String) -  
     * @param "RequestId" (optional.String) -  
     * @param "Action" (optional.String) -  
     * @param "ChangedObjectType" (optional.String) -  
     * @param "ChangedObjectId" (optional.String) -  
     * @param "ObjectRepr" (optional.String) -  
     * @param "Q" (optional.String) -  
     * @param "Time" (optional.String) -  
     * @param "IdN" (optional.String) -  
     * @param "IdLte" (optional.String) -  
     * @param "IdLt" (optional.String) -  
     * @param "IdGte" (optional.String) -  
     * @param "IdGt" (optional.String) -  
     * @param "UserN" (optional.String) -  
     * @param "UserNameN" (optional.String) -  
     * @param "UserNameIc" (optional.String) -  
     * @param "UserNameNic" (optional.String) -  
     * @param "UserNameIew" (optional.String) -  
     * @param "UserNameNiew" (optional.String) -  
     * @param "UserNameIsw" (optional.String) -  
     * @param "UserNameNisw" (optional.String) -  
     * @param "UserNameIe" (optional.String) -  
     * @param "UserNameNie" (optional.String) -  
     * @param "ActionN" (optional.String) -  
     * @param "ChangedObjectTypeN" (optional.String) -  
     * @param "ChangedObjectIdN" (optional.String) -  
     * @param "ChangedObjectIdLte" (optional.String) -  
     * @param "ChangedObjectIdLt" (optional.String) -  
     * @param "ChangedObjectIdGte" (optional.String) -  
     * @param "ChangedObjectIdGt" (optional.String) -  
     * @param "ObjectReprN" (optional.String) -  
     * @param "ObjectReprIc" (optional.String) -  
     * @param "ObjectReprNic" (optional.String) -  
     * @param "ObjectReprIew" (optional.String) -  
     * @param "ObjectReprNiew" (optional.String) -  
     * @param "ObjectReprIsw" (optional.String) -  
     * @param "ObjectReprNisw" (optional.String) -  
     * @param "ObjectReprIe" (optional.String) -  
     * @param "ObjectReprNie" (optional.String) -  
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.

@return InlineResponse20041
*/

type ExtrasApiExtrasObjectChangesListOpts struct { 
	Id optional.String
	User optional.String
	UserName optional.String
	RequestId optional.String
	Action optional.String
	ChangedObjectType optional.String
	ChangedObjectId optional.String
	ObjectRepr optional.String
	Q optional.String
	Time optional.String
	IdN optional.String
	IdLte optional.String
	IdLt optional.String
	IdGte optional.String
	IdGt optional.String
	UserN optional.String
	UserNameN optional.String
	UserNameIc optional.String
	UserNameNic optional.String
	UserNameIew optional.String
	UserNameNiew optional.String
	UserNameIsw optional.String
	UserNameNisw optional.String
	UserNameIe optional.String
	UserNameNie optional.String
	ActionN optional.String
	ChangedObjectTypeN optional.String
	ChangedObjectIdN optional.String
	ChangedObjectIdLte optional.String
	ChangedObjectIdLt optional.String
	ChangedObjectIdGte optional.String
	ChangedObjectIdGt optional.String
	ObjectReprN optional.String
	ObjectReprIc optional.String
	ObjectReprNic optional.String
	ObjectReprIew optional.String
	ObjectReprNiew optional.String
	ObjectReprIsw optional.String
	ObjectReprNisw optional.String
	ObjectReprIe optional.String
	ObjectReprNie optional.String
	Limit optional.Int32
	Offset optional.Int32
}

func (a *ExtrasApiService) ExtrasObjectChangesList(ctx context.Context, localVarOptionals *ExtrasApiExtrasObjectChangesListOpts) (InlineResponse20041, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20041
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/object-changes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.User.IsSet() {
		localVarQueryParams.Add("user", parameterToString(localVarOptionals.User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserName.IsSet() {
		localVarQueryParams.Add("user_name", parameterToString(localVarOptionals.UserName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestId.IsSet() {
		localVarQueryParams.Add("request_id", parameterToString(localVarOptionals.RequestId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Action.IsSet() {
		localVarQueryParams.Add("action", parameterToString(localVarOptionals.Action.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectType.IsSet() {
		localVarQueryParams.Add("changed_object_type", parameterToString(localVarOptionals.ChangedObjectType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectId.IsSet() {
		localVarQueryParams.Add("changed_object_id", parameterToString(localVarOptionals.ChangedObjectId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectRepr.IsSet() {
		localVarQueryParams.Add("object_repr", parameterToString(localVarOptionals.ObjectRepr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Time.IsSet() {
		localVarQueryParams.Add("time", parameterToString(localVarOptionals.Time.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLte.IsSet() {
		localVarQueryParams.Add("id__lte", parameterToString(localVarOptionals.IdLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLt.IsSet() {
		localVarQueryParams.Add("id__lt", parameterToString(localVarOptionals.IdLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGte.IsSet() {
		localVarQueryParams.Add("id__gte", parameterToString(localVarOptionals.IdGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGt.IsSet() {
		localVarQueryParams.Add("id__gt", parameterToString(localVarOptionals.IdGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserN.IsSet() {
		localVarQueryParams.Add("user__n", parameterToString(localVarOptionals.UserN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameN.IsSet() {
		localVarQueryParams.Add("user_name__n", parameterToString(localVarOptionals.UserNameN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIc.IsSet() {
		localVarQueryParams.Add("user_name__ic", parameterToString(localVarOptionals.UserNameIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNic.IsSet() {
		localVarQueryParams.Add("user_name__nic", parameterToString(localVarOptionals.UserNameNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIew.IsSet() {
		localVarQueryParams.Add("user_name__iew", parameterToString(localVarOptionals.UserNameIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNiew.IsSet() {
		localVarQueryParams.Add("user_name__niew", parameterToString(localVarOptionals.UserNameNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIsw.IsSet() {
		localVarQueryParams.Add("user_name__isw", parameterToString(localVarOptionals.UserNameIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNisw.IsSet() {
		localVarQueryParams.Add("user_name__nisw", parameterToString(localVarOptionals.UserNameNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameIe.IsSet() {
		localVarQueryParams.Add("user_name__ie", parameterToString(localVarOptionals.UserNameIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserNameNie.IsSet() {
		localVarQueryParams.Add("user_name__nie", parameterToString(localVarOptionals.UserNameNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActionN.IsSet() {
		localVarQueryParams.Add("action__n", parameterToString(localVarOptionals.ActionN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectTypeN.IsSet() {
		localVarQueryParams.Add("changed_object_type__n", parameterToString(localVarOptionals.ChangedObjectTypeN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdN.IsSet() {
		localVarQueryParams.Add("changed_object_id__n", parameterToString(localVarOptionals.ChangedObjectIdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdLte.IsSet() {
		localVarQueryParams.Add("changed_object_id__lte", parameterToString(localVarOptionals.ChangedObjectIdLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdLt.IsSet() {
		localVarQueryParams.Add("changed_object_id__lt", parameterToString(localVarOptionals.ChangedObjectIdLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdGte.IsSet() {
		localVarQueryParams.Add("changed_object_id__gte", parameterToString(localVarOptionals.ChangedObjectIdGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangedObjectIdGt.IsSet() {
		localVarQueryParams.Add("changed_object_id__gt", parameterToString(localVarOptionals.ChangedObjectIdGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprN.IsSet() {
		localVarQueryParams.Add("object_repr__n", parameterToString(localVarOptionals.ObjectReprN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIc.IsSet() {
		localVarQueryParams.Add("object_repr__ic", parameterToString(localVarOptionals.ObjectReprIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNic.IsSet() {
		localVarQueryParams.Add("object_repr__nic", parameterToString(localVarOptionals.ObjectReprNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIew.IsSet() {
		localVarQueryParams.Add("object_repr__iew", parameterToString(localVarOptionals.ObjectReprIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNiew.IsSet() {
		localVarQueryParams.Add("object_repr__niew", parameterToString(localVarOptionals.ObjectReprNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIsw.IsSet() {
		localVarQueryParams.Add("object_repr__isw", parameterToString(localVarOptionals.ObjectReprIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNisw.IsSet() {
		localVarQueryParams.Add("object_repr__nisw", parameterToString(localVarOptionals.ObjectReprNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprIe.IsSet() {
		localVarQueryParams.Add("object_repr__ie", parameterToString(localVarOptionals.ObjectReprIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectReprNie.IsSet() {
		localVarQueryParams.Add("object_repr__nie", parameterToString(localVarOptionals.ObjectReprNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20041
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Retrieve a list of recent changes.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this object change.

@return ObjectChange
*/
func (a *ExtrasApiService) ExtrasObjectChangesRead(ctx context.Context, id int32) (ObjectChange, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ObjectChange
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/object-changes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ObjectChange
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Compile all reports and their related results (if any). Result data is deferred in the list view.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().


*/
func (a *ExtrasApiService) ExtrasReportsList(ctx context.Context) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/reports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService
Retrieve a single Report identified as \&quot;&lt;module&gt;.&lt;report&gt;\&quot;.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id


*/
func (a *ExtrasApiService) ExtrasReportsRead(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/reports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService
Run a Report and create a new ReportResult, overwriting any previous result for the Report.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id


*/
func (a *ExtrasApiService) ExtrasReportsRun(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/reports/{id}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().


*/
func (a *ExtrasApiService) ExtrasScriptsList(ctx context.Context) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/scripts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id


*/
func (a *ExtrasApiService) ExtrasScriptsRead(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/scripts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param data

@return Tag
*/
func (a *ExtrasApiService) ExtrasTagsCreate(ctx context.Context, data Tag) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this tag.


*/
func (a *ExtrasApiService) ExtrasTagsDelete(ctx context.Context, id int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExtrasApiExtrasTagsListOpts - Optional Parameters:
     * @param "Id" (optional.String) -  
     * @param "Name" (optional.String) -  
     * @param "Slug" (optional.String) -  
     * @param "Color" (optional.String) -  
     * @param "Q" (optional.String) -  
     * @param "IdN" (optional.String) -  
     * @param "IdLte" (optional.String) -  
     * @param "IdLt" (optional.String) -  
     * @param "IdGte" (optional.String) -  
     * @param "IdGt" (optional.String) -  
     * @param "NameN" (optional.String) -  
     * @param "NameIc" (optional.String) -  
     * @param "NameNic" (optional.String) -  
     * @param "NameIew" (optional.String) -  
     * @param "NameNiew" (optional.String) -  
     * @param "NameIsw" (optional.String) -  
     * @param "NameNisw" (optional.String) -  
     * @param "NameIe" (optional.String) -  
     * @param "NameNie" (optional.String) -  
     * @param "SlugN" (optional.String) -  
     * @param "SlugIc" (optional.String) -  
     * @param "SlugNic" (optional.String) -  
     * @param "SlugIew" (optional.String) -  
     * @param "SlugNiew" (optional.String) -  
     * @param "SlugIsw" (optional.String) -  
     * @param "SlugNisw" (optional.String) -  
     * @param "SlugIe" (optional.String) -  
     * @param "SlugNie" (optional.String) -  
     * @param "ColorN" (optional.String) -  
     * @param "ColorIc" (optional.String) -  
     * @param "ColorNic" (optional.String) -  
     * @param "ColorIew" (optional.String) -  
     * @param "ColorNiew" (optional.String) -  
     * @param "ColorIsw" (optional.String) -  
     * @param "ColorNisw" (optional.String) -  
     * @param "ColorIe" (optional.String) -  
     * @param "ColorNie" (optional.String) -  
     * @param "Limit" (optional.Int32) -  Number of results to return per page.
     * @param "Offset" (optional.Int32) -  The initial index from which to return the results.

@return InlineResponse20042
*/

type ExtrasApiExtrasTagsListOpts struct { 
	Id optional.String
	Name optional.String
	Slug optional.String
	Color optional.String
	Q optional.String
	IdN optional.String
	IdLte optional.String
	IdLt optional.String
	IdGte optional.String
	IdGt optional.String
	NameN optional.String
	NameIc optional.String
	NameNic optional.String
	NameIew optional.String
	NameNiew optional.String
	NameIsw optional.String
	NameNisw optional.String
	NameIe optional.String
	NameNie optional.String
	SlugN optional.String
	SlugIc optional.String
	SlugNic optional.String
	SlugIew optional.String
	SlugNiew optional.String
	SlugIsw optional.String
	SlugNisw optional.String
	SlugIe optional.String
	SlugNie optional.String
	ColorN optional.String
	ColorIc optional.String
	ColorNic optional.String
	ColorIew optional.String
	ColorNiew optional.String
	ColorIsw optional.String
	ColorNisw optional.String
	ColorIe optional.String
	ColorNie optional.String
	Limit optional.Int32
	Offset optional.Int32
}

func (a *ExtrasApiService) ExtrasTagsList(ctx context.Context, localVarOptionals *ExtrasApiExtrasTagsListOpts) (InlineResponse20042, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse20042
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Slug.IsSet() {
		localVarQueryParams.Add("slug", parameterToString(localVarOptionals.Slug.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Color.IsSet() {
		localVarQueryParams.Add("color", parameterToString(localVarOptionals.Color.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Q.IsSet() {
		localVarQueryParams.Add("q", parameterToString(localVarOptionals.Q.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdN.IsSet() {
		localVarQueryParams.Add("id__n", parameterToString(localVarOptionals.IdN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLte.IsSet() {
		localVarQueryParams.Add("id__lte", parameterToString(localVarOptionals.IdLte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdLt.IsSet() {
		localVarQueryParams.Add("id__lt", parameterToString(localVarOptionals.IdLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGte.IsSet() {
		localVarQueryParams.Add("id__gte", parameterToString(localVarOptionals.IdGte.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdGt.IsSet() {
		localVarQueryParams.Add("id__gt", parameterToString(localVarOptionals.IdGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameN.IsSet() {
		localVarQueryParams.Add("name__n", parameterToString(localVarOptionals.NameN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIc.IsSet() {
		localVarQueryParams.Add("name__ic", parameterToString(localVarOptionals.NameIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNic.IsSet() {
		localVarQueryParams.Add("name__nic", parameterToString(localVarOptionals.NameNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIew.IsSet() {
		localVarQueryParams.Add("name__iew", parameterToString(localVarOptionals.NameIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNiew.IsSet() {
		localVarQueryParams.Add("name__niew", parameterToString(localVarOptionals.NameNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIsw.IsSet() {
		localVarQueryParams.Add("name__isw", parameterToString(localVarOptionals.NameIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNisw.IsSet() {
		localVarQueryParams.Add("name__nisw", parameterToString(localVarOptionals.NameNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameIe.IsSet() {
		localVarQueryParams.Add("name__ie", parameterToString(localVarOptionals.NameIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameNie.IsSet() {
		localVarQueryParams.Add("name__nie", parameterToString(localVarOptionals.NameNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugN.IsSet() {
		localVarQueryParams.Add("slug__n", parameterToString(localVarOptionals.SlugN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIc.IsSet() {
		localVarQueryParams.Add("slug__ic", parameterToString(localVarOptionals.SlugIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNic.IsSet() {
		localVarQueryParams.Add("slug__nic", parameterToString(localVarOptionals.SlugNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIew.IsSet() {
		localVarQueryParams.Add("slug__iew", parameterToString(localVarOptionals.SlugIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNiew.IsSet() {
		localVarQueryParams.Add("slug__niew", parameterToString(localVarOptionals.SlugNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIsw.IsSet() {
		localVarQueryParams.Add("slug__isw", parameterToString(localVarOptionals.SlugIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNisw.IsSet() {
		localVarQueryParams.Add("slug__nisw", parameterToString(localVarOptionals.SlugNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugIe.IsSet() {
		localVarQueryParams.Add("slug__ie", parameterToString(localVarOptionals.SlugIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlugNie.IsSet() {
		localVarQueryParams.Add("slug__nie", parameterToString(localVarOptionals.SlugNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorN.IsSet() {
		localVarQueryParams.Add("color__n", parameterToString(localVarOptionals.ColorN.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIc.IsSet() {
		localVarQueryParams.Add("color__ic", parameterToString(localVarOptionals.ColorIc.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNic.IsSet() {
		localVarQueryParams.Add("color__nic", parameterToString(localVarOptionals.ColorNic.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIew.IsSet() {
		localVarQueryParams.Add("color__iew", parameterToString(localVarOptionals.ColorIew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNiew.IsSet() {
		localVarQueryParams.Add("color__niew", parameterToString(localVarOptionals.ColorNiew.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIsw.IsSet() {
		localVarQueryParams.Add("color__isw", parameterToString(localVarOptionals.ColorIsw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNisw.IsSet() {
		localVarQueryParams.Add("color__nisw", parameterToString(localVarOptionals.ColorNisw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorIe.IsSet() {
		localVarQueryParams.Add("color__ie", parameterToString(localVarOptionals.ColorIe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ColorNie.IsSet() {
		localVarQueryParams.Add("color__nie", parameterToString(localVarOptionals.ColorNie.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse20042
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this tag.
 * @param data

@return Tag
*/
func (a *ExtrasApiService) ExtrasTagsPartialUpdate(ctx context.Context, id int32, data Tag) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService
Call to super to allow for caching
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this tag.

@return Tag
*/
func (a *ExtrasApiService) ExtrasTagsRead(ctx context.Context, id int32) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ExtrasApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A unique integer value identifying this tag.
 * @param data

@return Tag
*/
func (a *ExtrasApiService) ExtrasTagsUpdate(ctx context.Context, id int32, data Tag) (Tag, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tag
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/extras/tags/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &data
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Tag
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
